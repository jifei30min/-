C51 COMPILER V9.54   MAIN                                                                  04/12/2025 11:38:21 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Software\keil5ARM\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Diver) DEBUG OBJECTE
                    -XTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //头文件声明区
   2          #include <STC15F2K60S2.H>//单片机存储区头文件
   3          #include <Init.H>//初始化底层驱动专用头文件
   4          #include <Led.H>//Led底层取到专用头文件
   5          #include <Seg.h>//按键底层驱动专用头文件
   6          #include <Key.h>//数码管底层驱动专用头文件
   7          #include <ds1302.h>//时钟驱动专用头文件
   8          #include "onewire.h"//温度专用模块
   9          #include "iic.h" //I2c模块
  10          #include "intrins.h"
  11          
  12          //声明变量
  13          unsigned char Key_Val,Key_Down,Key_Up,Key_Old;//按键扫描专用变量
  14          unsigned int Key_Slow_Down; //按键减速专用变量10ms
  15          unsigned char Seg_Buf[8] = {1,2,3,4,5,6,7,8}; //数码管显示数据存放数组
  16          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  17          unsigned char Seg_Pos;//数码管扫描变量
  18          unsigned int Seg_Slow_Down; //数码管减速专用变量500ms
  19          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0}; //LED显示数据存放数组
  20          
  21          unsigned char Smg_Mode = 1;//数码管显示功能 1:数据界面 2:参数界面
  22          float temprate;//DS18B20采集环境温度
  23          unsigned char temprate_disp[] = {30, 20};//温度参数显示 温度上限默认为30 下限默认为20
  24          unsigned char temprate_set[] = {30, 20};//温度参数设置
  25          bit System_temprate = 0;//温度亮灭切换比特位
  26          unsigned int temprate_slow = 0;//温度切换延时函数500ms
  27          unsigned char temprate_select = 0;//温度参数选择 0选择MAX 1选择MIN
  28          
  29          //延时函数
  30          void Delay750ms()   //@12.000MHz
  31          {
  32   1        unsigned char i, j, k;
  33   1      
  34   1        _nop_();
  35   1        i = 6;
  36   1        j = 180;
  37   1        k = 26;
  38   1        do
  39   1        {
  40   2          do
  41   2          {
  42   3            while (--k);
  43   3          } while (--j);
  44   2        } while (--i);
  45   1      }
  46          
  47          //按键处理函数
  48          void Key_Proc()
  49          {
  50   1        //如果Key_Slow_Down非零，if条件成立，执行return;语句，Key_Proc()会停止执行，不会执行后面的Key_Slow_Down =
             - 1;
  51   1        if(Key_Slow_Down) return;
  52   1        
  53   1        //Key_Slow_Down == 0时  Key_Slow_Down变为1
C51 COMPILER V9.54   MAIN                                                                  04/12/2025 11:38:21 PAGE 2   

  54   1        Key_Slow_Down = 1;//按键减速程序
  55   1        
  56   1        //照搬代码
  57   1        Key_Val = Key_Read(); //读取按下的键码值
  58   1        
  59   1        Key_Down = Key_Val & (Key_Val ^ Key_Old);//捕捉下降沿 //按键按下那一瞬间的值
  60   1        
  61   1        Key_Up = ~Key_Val & (Key_Val ^ Key_Old);//捕捉上升沿 //按键抬起那一瞬间的值
  62   1        
  63   1        Key_Old = Key_Val;//辅助扫描 //按键一直按下的时候的值
  64   1        
  65   1        switch(Key_Down)
  66   1        {
  67   2          case 4:
  68   2            if(++Smg_Mode == 3) Smg_Mode = 1;
  69   2          
  70   2            //Smg_Mode++完之后=2 进入参数界面
  71   2            if(Smg_Mode == 2) //从数据界面切换到参数界面
  72   2            {
  73   3              temprate_select = 1;//每次从数据界面切换到参数界面 都默认选中min
  74   3              temprate_disp[0] = temprate_set[0];
  75   3              temprate_disp[1] = temprate_set[1];       
  76   3            }
  77   2            
  78   2            //从参数界面切换到数据界面后
  79   2            if(Smg_Mode == 1)
  80   2            {
  81   3              //如果MAX >= MIN temprate_disp 的值赋给 temprate_set 然后再切换到数据界面时 
  82   3              //将赋给 temprate_set的值 给 temprate_disp 使其每一次都能显示上次参数设置的值
  83   3              //如果MAX < MIN 说明参数设置不成功 则 temprate_set的初始值传给temprate_disp
  84   3              //则将改变的
  85   3              if(temprate_disp[0] >= temprate_disp[1])
  86   3              {
  87   4                temprate_set[0] = temprate_disp[0];
  88   4                temprate_set[1] = temprate_disp[1];
  89   4              }
  90   3            }
  91   2          break;
  92   2          
  93   2          case 5:
  94   2            if(Smg_Mode == 2)
  95   2            {
  96   3              if(++temprate_select == 2) temprate_select = 0;
  97   3            }
  98   2          
  99   2          break;
 100   2          
 101   2          case 6:
 102   2            if(Smg_Mode == 2)
 103   2            {
 104   3      //        if(temprate_select == 0)
 105   3      //        {
 106   3      //          if(++temprate_disp[0] == 100) temprate_disp[0] = 0;
 107   3      //        }       
 108   3      //        if(temprate_select == 1) 
 109   3      //        { 
 110   3      //          if(++temprate_disp[1] == 100) temprate_disp[1] = 0;
 111   3      //        }           
 112   3              if(++temprate_disp[temprate_select] == 100) temprate_disp[temprate_select] = 0;
 113   3            }   
 114   2          break;
 115   2          
C51 COMPILER V9.54   MAIN                                                                  04/12/2025 11:38:21 PAGE 3   

 116   2          case 7:
 117   2            if(Smg_Mode == 2)
 118   2            {
 119   3      //        if(temprate_select == 0)
 120   3      //        {
 121   3      //          if(--temprate_disp[0] == 255) temprate_disp[0] = 99;  
 122   3      //        }       
 123   3      //        if(temprate_select == 1)
 124   3      //        {
 125   3      //          if(--temprate_disp[1] == 255) temprate_disp[1] = 99;
 126   3      //        }     
 127   3              if(--temprate_disp[temprate_select] == 255) temprate_disp[temprate_select] = 99;
 128   3            } 
 129   2          break;
 130   2        }
 131   1      }
 132          
 133          //信息处理函数
 134          void Seg_Proc()
 135          {
 136   1        if(Seg_Slow_Down) return;
 137   1        Seg_Slow_Down = 1;//数码管减速程序
 138   1        
 139   1        temprate = read_t();
 140   1        switch(Smg_Mode)
 141   1        {
 142   2          case 1:
 143   2            Seg_Buf[0] = 12;
 144   2            Seg_Buf[1] = 17;
 145   2            Seg_Buf[2] = 17;
 146   2            Seg_Buf[3] = 17;
 147   2            Seg_Buf[4] = 17;
 148   2            Seg_Buf[5] = 17;
 149   2            Seg_Buf[6] = (unsigned char)temprate / 10 % 10;
 150   2            Seg_Buf[7] = (unsigned char)temprate % 10;
 151   2          
 152   2          
 153   2          break;
 154   2          
 155   2          case 2:
 156   2            Seg_Buf[0] = 18;
 157   2            Seg_Buf[1] = 17;
 158   2            Seg_Buf[2] = 17;
 159   2            Seg_Buf[3] = temprate_disp[0] / 10 % 10;
 160   2            Seg_Buf[4] = temprate_disp[0] % 10;
 161   2            Seg_Buf[5] = 17;
 162   2            Seg_Buf[6] = temprate_disp[1] / 10 % 10;
 163   2            Seg_Buf[7] = temprate_disp[1] % 10;     
 164   2            if(temprate_select == 0)
 165   2            {
 166   3              Seg_Buf[3] = System_temprate? temprate_disp[0] / 10 % 10 : 17;
 167   3              Seg_Buf[4] = System_temprate? temprate_disp[0] % 10 : 17;
 168   3            }
 169   2          
 170   2            if(temprate_select == 1)
 171   2            {
 172   3              Seg_Buf[6] = System_temprate? temprate_disp[1] / 10 % 10 : 17;
 173   3              Seg_Buf[7] = System_temprate? temprate_disp[1] % 10 : 17;
 174   3            } 
 175   2          break;
 176   2        }
 177   1        
C51 COMPILER V9.54   MAIN                                                                  04/12/2025 11:38:21 PAGE 4   

 178   1      }
 179          
 180          //其他显示函数
 181          void Led_Proc() 
 182          {
 183   1        if(temprate > temprate_disp[0]) Da_Write(4.0 * 51.0);
 184   1        if(temprate >= temprate_disp[1] && temprate <= temprate_disp[0]) Da_Write(3.0 * 51.0); 
 185   1        if(temprate < temprate_disp[1]) Da_Write(2.0 * 51.0);
 186   1        
 187   1        if(temprate > temprate_disp[0]) Led_Disp(0,1);
 188   1        if(temprate >= temprate_disp[1] && temprate <= temprate_disp[0]) Led_Disp(1,1); 
 189   1        if(temprate < temprate_disp[1]) Led_Disp(2,1);
 190   1        if(temprate_disp[0] < temprate_disp[1]) Led_Disp(3,1); 
 191   1      }
 192          
 193          //定时器0初始化函数
 194          //12MHZ 定时器0 1ms 16位自动重装载 12T
 195          void Timer0Init()   //1毫秒@12.000MHz
 196          {
 197   1        AUXR &= 0x7F;   //定时器时钟12T模式
 198   1        TMOD &= 0xF0;   //设置定时器模式
 199   1        TL0 = 0x18;   //设置定时初值
 200   1        TH0 = 0xFC;   //设置定时初值
 201   1        TF0 = 0;    //清除TF0标志
 202   1        TR0 = 1;    //定时器0开始计时
 203   1        
 204   1        ET0 = 1;
 205   1        EA = 1;
 206   1      }
 207          
 208          
 209          //定时器0中断服务函数
 210          void Timer0Service() interrupt 1
 211          {
 212   1        //自动重装载 不需要赋初值
 213   1        
 214   1        Key_Slow_Down++;
 215   1        if(Key_Slow_Down == 10) Key_Slow_Down=0; //if(++Key_Slow_Down == 10)Key_Slow_Down=0;
 216   1        
 217   1        Seg_Slow_Down++;
 218   1        if(Seg_Slow_Down == 500) Seg_Slow_Down=0;//if(++Seg_Slow_Down == 500) Seg_Slow_Down=0;
 219   1        
 220   1        if(++Seg_Pos == 8) Seg_Pos = 0;
 221   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 222   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 223   1        
 224   1        if(++temprate_slow == 500)
 225   1        {
 226   2          temprate_slow = 0;
 227   2          System_temprate = !System_temprate;
 228   2        }
 229   1      }
 230          
 231          //Main函数
 232          void main()
 233          {
 234   1        read_t();
 235   1        Delay750ms();
 236   1        System_Init();
 237   1        Timer0Init();
 238   1        
 239   1        while(1)
C51 COMPILER V9.54   MAIN                                                                  04/12/2025 11:38:21 PAGE 5   

 240   1        {
 241   2          Key_Proc();
 242   2          Seg_Proc();
 243   2          Led_Proc();
 244   2        }
 245   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    795    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
